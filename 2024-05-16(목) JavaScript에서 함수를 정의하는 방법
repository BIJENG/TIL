const test = function () {} (함수 표현식)
이것은 함수를 변수에 할당하는 함수 표현식의 형태입니다.
함수를 정의하고 그것을 변수에 할당합니다. 이 변수는 함수를 참조할 수 있습니다.
호이스팅(hoisting)이 발생하지 않습니다. 즉, 변수가 선언되기 전에 이 함수에 접근하려고 하면 오류가 발생합니다.
주로 함수가 필요한 지점에서 동적으로 생성되어야 할 때 사용됩니다.
ex)
const test = function () {
    console.log("This is a function expression");
};


function test () {} (함수 선언문)
이것은 함수 선언문의 형태입니다.
스크립트의 최상위 레벨이나 함수 내에서 사용될 수 있습니다.
호이스팅이 발생합니다. 즉, 선언하기 전에도 해당 함수에 접근할 수 있습니다.
주로 전역 함수나 다른 함수 내에서 여러 번 재사용될 함수를 정의할 때 사용됩니다.
ex)
function test() {
    console.log("This is a function declaration");
}


const test = () => {} (화살표 함수)
ES6(ES2015)에서 도입된 새로운 함수 표현식입니다.
함수를 변수에 할당하는 형태로 사용됩니다.
함수를 간결하게 표현할 수 있으며, 명시적인 return 문이 필요 없습니다. 단일 표현식이 자동으로 반환됩니다.
this의 값이 정적으로 결정되어 있어서, 일반 함수와 다르게 this가 상위 스코프를 가리키지 않습니다.
주로 간단한 함수를 정의할 때 사용됩니다.
ex)
const test = () => {
    console.log("This is an arrow function");
};

**** 따라서 큰 틀에서 사용되는 함수는 함수 선언문으로, 함수 내부의 간단한 구현이나 함수의 인자로 전달되는 함수는 함수 표현식이나 화살표 함수를 사용하는 것이 일반적인 패턴



함수 표현식과 화살표 함수는 사용 목적과 일부 측면에서 유사할 수 있습니다. 주요 유사점과 차이점

유사점
 1. 간결성
  함수 표현식과 화살표 함수는 모두 함수를 간결하게 정의할 수 있습니다.
  특히 함수의 본문이 단일 표현식인 경우에는 더욱 간결하게 작성할 수 있습니다.
  
 2. 익명 함수로의 사용:
  둘 다 익명 함수로 사용될 수 있습니다. 즉, 함수를 변수에 할당하여 사용할 수 있습니다.
  
 3. 클로저 생성:
  함수 표현식과 화살표 함수는 모두 클로저를 생성할 수 있습니다. 따라서 외부 스코프의 변수를 참조할 수 있습니다.


차이점
 1. this 바인딩
  가장 큰 차이점 중 하나입니다. 함수 표현식에서의 this는 실행 컨텍스트에 따라 동적으로 결정되지만, 화살표 함수에서의 this는 정적으로 결정됩니다. 즉, 화살표 함수에서의 this는 함수가 정의된 스코프를 가리킵니다.
  이러한 특성으로 인해 화살표 함수는 메소드로 사용할 때 주의가 필요합니다.
  
 2. 생성자 함수로의 사용
  함수 표현식은 생성자 함수로 사용할 수 있지만, 화살표 함수는 생성자 함수로 사용할 수 없습니다. 화살표 함수는 항상 익명이며, 자신의 this, arguments, super, new.target을 바인딩하지 않기 때문입니다.
  
 3. arguments 객체
  함수 표현식에서는 arguments 객체를 사용할 수 있지만, 화살표 함수에서는 사용할 수 없습니다. 화살표 함수 내에서 arguments를 참조하면 외부 스코프에서 해당 변수를 찾게 됩니다.
  


