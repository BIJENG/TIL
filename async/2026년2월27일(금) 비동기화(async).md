# 🚀 FastAPI 비동기 프로그래밍 & 핵심 개념 정리 노트

이 문서는 파이썬과 FastAPI 환경에서 사용되는 **비동기 프로그래밍(Asynchronous Programming)**과 주요 핵심 문법들을 이해하기 위해 작성된 학습 노트입니다.

---

## 1. 동기(Sync) vs 비동기(Async)의 차이

가장 쉬운 비유는 **'카페에서 커피를 주문하는 방식'**입니다.

- **동기 (Synchronous):** 손님이 주문을 하고 커피가 나올 때까지 카운터 앞에서 **아무것도 안 하고 기다리는 방식**입니다. 앞사람의 커피가 안 나오면 뒷사람은 주문조차 할 수 없습니다. (Python의 기본 동작 방식)
- **비동기 (Asynchronous):** 손님이 주문을 하고 **진동벨을 받은 뒤 자리로 가서 다른 일(핸드폰 등)을 하는 방식**입니다. 주방장은 커피를 내리는(기다리는) 동안 다음 사람의 주문을 계속 받습니다.

### 💻 코드 비교

```python
import time
import asyncio

# [동기식] 1초 동안 프로그램 전체가 '얼음' 상태가 됨
def sync_work():
    time.sleep(1)

# [비동기식] 1초 동안 기다리지만, 그동안 다른 함수가 실행될 수 있게 자리를 양보함
async def async_work():
    await asyncio.sleep(1)
```

---

## 2. 비동기 문법의 핵심: `async`와 `await`

### ① `async def`와 코루틴(주문서)

파이썬에서 함수 앞에 `async`를 붙이면, 그 함수는 호출(`()`)했을 때 바로 실행되지 않고 **코루틴(Coroutine) 객체**를 반환합니다.

- **비유:** 요리를 바로 시작하는 것이 아니라, **"이 요리를 해주세요"라는 '주문서'**를 발행하는 것과 같습니다.

### ② `asyncio.run()` (이벤트 루프 / 주방장)

만들어진 코루틴(주문서)을 실제로 실행하려면, 이를 처리해 줄 엔진이 필요합니다.

```python
async def hello():
    print("Hello!")

coro = hello() # 실행 안 됨! 주문서(코루틴 객체)만 생성됨
asyncio.run(coro) # 주방장(루프)에게 주문서를 전달해야 비로소 "Hello!" 출력
```

### ③ `await`를 쓰기 위한 2가지 절대 조건

`await`는 대기 시간이 발생할 때 "잠깐 다른 일 하고 와!"라고 양보하는 키워드입니다.

1. **반드시 `async def` 함수 안에서만 사용해야 합니다.** (일반 함수에서 쓰면 에러 발생)
2. **뒤에는 반드시 '기다릴 수 있는(Awaitable)' 객체만 와야 합니다.** (예: 다른 코루틴, Task 등)

---

## 3. 여러 작업을 동시에! `asyncio.gather`

여러 개의 비동기 작업을 한 번에 묶어서(gather) 실행할 때 사용합니다. 각 작업이 끝나는 순서에 상관없이, 전체 작업이 가장 빠르게 끝나는 시간에 맞춰집니다.

```python
import asyncio

async def make_coffee():
    await asyncio.sleep(2) # 2초 소요
    return "커피 완료"

async def make_toast():
    await asyncio.sleep(3) # 3초 소요
    return "토스트 완료"

async def main():
    # 동기식이라면 5초(2+3)가 걸리지만, gather를 쓰면 가장 오래 걸리는 3초 만에 모두 완료됨
    results = await asyncio.gather(make_coffee(), make_toast())
    print(results) # ['커피 완료', '토스트 완료']

asyncio.run(main())
```

---

## 4. 비동기 프로그래밍의 단점 (주의할 점)

비동기가 서버 성능에는 좋지만, 개발자에게는 다음과 같은 고충이 따릅니다.

1. **가독성 저하:** 코드의 실행 순서가 뒤죽박죽이 될 수 있어 머릿속으로 흐름을 쫓기 어렵습니다.
2. **디버깅의 지옥:** 에러가 터졌을 때, 이 작업이 어디서부터 시작된 건지 추적(Stack Trace)하기가 매우 까다롭습니다.
3. **전염성 (Viral Nature):** 프로젝트 중간에 비동기(`await`)를 하나라도 쓰려면, 그 함수를 호출하는 모든 껍데기 함수가 줄줄이 `async def`로 바뀌어야 합니다. (하나라도 꼬이면 서버 전체가 멈출 수 있음)

---

## 5. `yield`와 제너레이터 (FastAPI의 `Depends` 원리)

`return`과 비슷하지만 완전히 다른 역할을 하는 키워드입니다.

- **`return`:** 값을 던져주고 함수를 아예 **종료**시켜 버립니다.
- **`yield`:** 값을 던져주고 함수를 그 자리에서 **일시정지(양보)**시킵니다. 나중에 다시 부르면 멈췄던 곳부터 재개합니다.

### 💡 FastAPI에서 DB 세션 관리에 쓰이는 이유 (Setup & Teardown)

FastAPI의 `Depends`는 이 `yield`의 성질을 이용해 자원(DB 연결 등)을 안전하게 관리합니다.

```python
def get_session():
    # 1. 요청이 들어오면 DB 연결을 생성 (Setup)
    session = "DB_세션_객체"

    # 2. 핸들러(API)에게 세션을 빌려주고 여기서 멈춤 (일시정지)
    yield session

    # 3. 핸들러가 응답을 마치고 나면, 다시 여기로 돌아와서 세션을 닫음 (Teardown)
    print("DB 세션을 안전하게 종료합니다.")
    # session.close()
```
